const express = require('express');
const client = require('prom-client');
const { Telegraf } = require('telegraf');
const { createClient } = require('redis');
const pino = require('pino');

// Logger
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true },
  },
});

const app = express();
const port = process.env.PORT || 7000;
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const REDIS_URL = process.env.REDIS_URL || 'redis://redis:6379';

// Prometheus Registry
const register = new client.Registry();
client.collectDefaultMetrics({ register });

// Metrics
const notificationsSent = new client.Counter({
  name: 'telegram_notifications_sent_total',
  help: 'Total notifications sent to users',
  labelNames: ['type'],
});
register.registerMetric(notificationsSent);

// Initialize Redis
const subscriber = createClient({ url: REDIS_URL });
const publisher = createClient({ url: REDIS_URL });

subscriber.on('error', (err) => logger.error({ err }, 'Redis Subscriber Error'));
publisher.on('error', (err) => logger.error({ err }, 'Redis Publisher Error'));

// Initialize Bot
if (!BOT_TOKEN) {
  logger.error('TELEGRAM_BOT_TOKEN is missing. Bot will not start.');
  process.exit(1);
}

const bot = new Telegraf(BOT_TOKEN);

// --- Command Handlers ---

const HELP_MESSAGE = `
ğŸ™ *Namaste! I am Guru Ji* ğŸ§˜â€â™‚ï¸
Your AI-powered Nifty 50 Trading Assistant.

*Here is what I can do for you:*

ğŸš€ *Market Intelligence*
â€¢ /feed - *Market Snapshot*: Get filtered Advance/Decline ratios and broad market sentiment.
â€¢ /high - *Top Gainers*: List of top 10 stocks driving the market up.
â€¢ /low - *Top Losers*: List of top 10 stocks dragging the market down.
â€¢ /movers - *Most Active*: Stocks with the highest trading volume today.

ğŸ§  *AI Analysis*
â€¢ /ownanalysis - *Guru's Wisdom*: Recent Buy/Sell signals generated by the AI engine.
â€¢ /status - *System Health*: Check if the Guru is online and connected.

ğŸ“¥ *Data Management*
â€¢ /backfill - *Historical Data*: Trigger a backfill job with custom date range.
â€¢ /livestatus - *Live Console*: Stream real-time backfill progress (use /stop to end).

ğŸ’¡ *Feedback*
â€¢ /suggest <text> - Send feedback (Type message on SAME LINE!)

ğŸ“° *Updates*
â€¢ /news - *Market News*: Latest headlines (Coming Soon).
â€¢ /subscribe <email> - Get daily stock updates & feature changelogs via Email!
â€¢ /stop - Unsubscribe from alerts / Stop live stream.

_Select a command above to start!_
`;

// --- Interactive Menu Keyboard ---
const { Markup } = require('telegraf');

const mainMenu = Markup.keyboard([
  ['ğŸ“Š Market Feed', 'ğŸš€ Top Gainers', 'ğŸ©¸ Top Losers'],
  ['ğŸ§  AI Analysis', 'ğŸ¥ System Status'],
  ['ğŸ“¥ Backfill', 'ğŸ“¡ Live Status'],
  ['ğŸ’¡ Suggest', 'ğŸ“° News'],
]).resize();

const sendMenu = (ctx, message = '') => {
  ctx.reply(message || HELP_MESSAGE, { parse_mode: 'Markdown', ...mainMenu });
};

bot.start(async (ctx) => {
  const chatId = ctx.chat.id;
  const username = ctx.from.username || 'Trader';

  try {
    await publisher.sAdd('telegram:subscribers', chatId.toString());
    logger.info({ chatId, username }, 'New subscriber');
    sendMenu(ctx, `Hello I am Guru Ji! ğŸ‘‹\nWelcome *${username}*.\n\n${HELP_MESSAGE}`);
  } catch (err) {
    logger.error({ err }, 'Failed to subscribe user');
    ctx.reply('âŒ System Error: Could not subscribe.');
  }
});

bot.help((ctx) => {
  sendMenu(ctx);
});

// Listen for "hi" or similar greetings
bot.hears(/^(hi|hello|hey|namaste)$/i, (ctx) => {
  sendMenu(
    ctx,
    `ğŸ™ *Namaste, ${ctx.from.username || 'Trader'}!*\n\nHow can Guru Ji assist you today?`
  );
});

// Handle Keyboard Button Presses
bot.hears(
  'ğŸ“Š Market Feed',
  (ctx) =>
    ctx.scene?.enter?.('feed') ||
    bot.handleUpdate({ message: { ...ctx.message, text: '/feed' } }, ctx)
);
bot.hears('ğŸš€ Top Gainers', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/high'));
bot.hears('ğŸ©¸ Top Losers', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/low'));
bot.hears('ğŸ§  AI Analysis', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/ownanalysis'));
bot.hears('ğŸ¥ System Status', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/status'));
bot.hears('ğŸ“¥ Backfill', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/backfill'));
bot.hears('ğŸ“¡ Live Status', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/livestatus'));
bot.hears('ğŸ’¡ Suggest', (ctx) =>
  ctx.reply('ğŸ’¡ To suggest, type: `/suggest Your suggestion here`', { parse_mode: 'Markdown' })
);
bot.hears('ğŸ“° News', (ctx) => ctx.telegram.sendMessage(ctx.chat.id, '/news'));

bot.command('suggest', async (ctx) => {
  const text = ctx.message.text.replace('/suggest', '').trim();
  logger.info({ user: ctx.from.username, text }, 'Suggestion Command Received');

  if (!text) {
    return ctx.reply(
      'âš ï¸ *Incorrect Format*\n\n' +
        'Please type the message on the *same line* as the command.\n\n' +
        'âœ… *Correct*:\n' +
        '`/suggest Add more charts`\n\n' +
        'âŒ *Wrong*:\n' +
        '`/suggest` [Enter]\n' +
        '(Typing message separately)',
      { parse_mode: 'Markdown' }
    );
  }

  try {
    const res = await axios.post('http://backend-api:4000/api/v1/suggestions', {
      user: ctx.from.username || 'Anonymous',
      text: text,
      source: 'telegram',
    });
    logger.info({ status: res.status, data: res.data }, 'Suggestion API Response');
    ctx.reply('ğŸ™ *Dhanyavac user*! Your suggestion has been noted.', { parse_mode: 'Markdown' });
  } catch (err) {
    logger.error({ err: err.message, stack: err.stack }, 'Suggestion Failed');
    ctx.reply('âŒ Failed to save suggestion. Try again later.');
  }
});

bot.command('subscribe', async (ctx) => {
  const email = ctx.message.text.replace('/subscribe', '').trim();
  const chatId = ctx.chat.id;
  const username = ctx.from.username || 'Anonymous';

  if (!email || !email.includes('@')) {
    return ctx.reply(
      'ğŸ“§ Please provide a valid email address.\nUsage: `/subscribe your@email.com`',
      { parse_mode: 'Markdown' }
    );
  }

  try {
    const res = await axios.post('http://backend-api:4000/api/v1/subscribers', {
      chatId: chatId,
      username: username,
      email: email,
    });

    if (res.data.success) {
      ctx.reply(
        'âœ… *Subscription Successful!* You are now on our list for regular updates and new feature releases.',
        { parse_mode: 'Markdown' }
      );
    } else {
      ctx.reply('âŒ Subscription failed. Please try again later.');
    }
  } catch (err) {
    logger.error({ err: err.message }, 'Subscription Failed');
    ctx.reply('âŒ System Error: Could not save subscription.');
  }
});

// --- Helper Functions ---
async function getMarketData() {
  const data = await publisher.get('market_view:latest');
  return data ? JSON.parse(data) : null;
}

const formatStock = (s) => `â€¢ *${s.symbol}*: ${s.change_pct.toFixed(2)}% (â‚¹${s.ltp})`;

bot.command('feed', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');

  const { breadth } = market;
  const msg =
    `ğŸ“Š *Market Snapshot* (${new Date().toLocaleTimeString()})\n\n` +
    `ğŸ“ˆ *Sentiment*: ${breadth.market_sentiment}\n` +
    `ğŸŸ¢ *Advance*: ${breadth.advance_count}\n` +
    `ğŸ”´ *Decline*: ${breadth.decline_count}\n` +
    `âš–ï¸ *A/D Ratio*: ${breadth.advance_decline.toFixed(2)}`;
  ctx.reply(msg, { parse_mode: 'Markdown' });
});

bot.command('high', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const list = market.top_gainers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸš€ *Top Gainers*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.command('low', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const list = market.top_losers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸ©¸ *Top Losers*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.command('movers', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ï¿½ Market data unavailable.');
  // Assuming most_active exists in market view schema, otherwise fallback to top_gainers
  const movers = market.most_active || market.top_gainers;
  const list = movers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸŒª *Most Active*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.command('news', (ctx) => {
  ctx.reply('ğŸ“° *Latest News*\n\nFeature coming soon! Integration with NewsAPI pending.', {
    parse_mode: 'Markdown',
  });
});

bot.command('ownanalysis', async (ctx) => {
  try {
    // Fetch last 5 signals from Redis List
    // LRANGE signals:history 0 4
    const history = await publisher.lRange('signals:history', 0, 4);

    if (!history || history.length === 0) {
      return ctx.reply('ğŸ§  No recent analysis available.');
    }

    const msgs = history
      .map((item) => {
        const s = JSON.parse(item);
        const icon = s.action === 'BUY' ? 'ğŸŸ¢' : 'ğŸ”´';
        return `${icon} *${s.symbol}* (${s.action}) @ â‚¹${s.price}\n   Conf: ${(s.confidence * 100).toFixed(0)}% | ${new Date(s.timestamp).toLocaleTimeString()}`;
      })
      .join('\n\n');

    ctx.reply(`ğŸ§  *Recent AI Analysis*\n\n${msgs}`, { parse_mode: 'Markdown' });
  } catch (err) {
    logger.error({ err }, 'Analysis Fetch Error');
    ctx.reply('âŒ Error fetching analysis.');
  }
});

const cron = require('node-cron');
const axios = require('axios');

// --- Scheduled Tasks ---
// 9:00 AM IST (India) = 03:30 UTC
cron.schedule('30 3 * * 1-5', () => {
  const msg =
    `ğŸŒ… *Good Morning Traders!* â˜€ï¸\n` +
    `Markets are opening soon. Guru Ji wishes you high profits!\n` +
    `_Check /feed for pre-market sentiment._`;
  broadcast(msg);
});

bot.command('status', async (ctx) => {
  ctx.reply('ğŸ” *Checking System Health*...');

  const services = [
    { name: 'API', url: 'http://backend-api:4000/health' },
    { name: 'Ingestion', url: 'http://ingestion:3000/health' }, // Assuming L1 exposes 3000
    { name: 'Analysis', url: 'http://analysis:8081/health' },
    { name: 'Aggregation', url: 'http://aggregation:8080/health' },
    { name: 'Signal', url: 'http://signal:8082/health' },
  ];

  let report = `ğŸ¥ *System Health Report*\n\n`;

  for (const s of services) {
    try {
      await axios.get(s.url, { timeout: 2000 });
      report += `âœ… *${s.name}*: UP\n`;
    } catch {
      report += `âŒ *${s.name}*: DOWN\n`;
    }
  }

  // Redis Check
  try {
    await publisher.ping();
    report += `âœ… *Redis*: UP\n`;
  } catch {
    report += `âŒ *Redis*: DOWN\n`;
  }

  // Data Stats (from Redis)
  const vol = await publisher.get('stats:daily_volume');
  report += `\nğŸ“Š *Data Processed*: ${vol || 0} rows today`;

  ctx.reply(report, { parse_mode: 'Markdown' });
});

// --- Live Status Sessions (per chat) ---
const liveStatusSessions = new Map(); // chatId -> { intervalId, messageId }

bot.command('backfill', async (ctx) => {
  const args = ctx.message.text.replace('/backfill', '').trim();
  const chatId = ctx.chat.id;

  // Default: 5 days, 1 minute candles
  let days = 5;
  let interval = 'ONE_MINUTE';

  // Parse arguments like "30d 1m" or "7d"
  const dayMatch = args.match(/(\d+)d/i);
  const intervalMatch = args.match(/(1m|5m|10m|15m|1h|1d)/i);

  if (dayMatch) days = parseInt(dayMatch[1], 10);
  if (intervalMatch) {
    const intervalMap = {
      '1m': 'ONE_MINUTE',
      '5m': 'FIVE_MINUTE',
      '10m': 'TEN_MINUTE',
      '15m': 'FIFTEEN_MINUTE',
      '1h': 'ONE_HOUR',
      '1d': 'ONE_DAY',
    };
    interval = intervalMap[intervalMatch[1].toLowerCase()] || 'ONE_MINUTE';
  }

  const jobId = `backfill-${Date.now()}`;
  const toDate = new Date();
  const fromDate = new Date(toDate.getTime() - days * 24 * 60 * 60 * 1000);

  const fromStr = fromDate.toISOString().split('T')[0];
  const toStr = toDate.toISOString().split('T')[0];

  try {
    // Trigger backfill via Redis command
    await publisher.publish(
      'system:commands',
      JSON.stringify({
        command: 'START_BACKFILL',
        params: {
          fromDate: fromStr,
          toDate: toStr,
          interval: interval,
          triggerSource: 'telegram',
          jobId: jobId,
        },
      })
    );

    const msg =
      `âš¡ *Backfill Job Started*\n\n` +
      `ğŸ“Š *Job ID*: \`${jobId}\`\n` +
      `ğŸ“¦ *Symbols*: ALL (Nifty 50)\n` +
      `ğŸ“… *Range*: ${fromStr} to ${toStr}\n` +
      `â± *Interval*: ${interval}\n` +
      `ğŸ•’ *Started*: ${new Date().toLocaleString()}\n\n` +
      `_You will receive a notification when complete._\n` +
      `_Use /livestatus to stream live progress._`;

    ctx.reply(msg, { parse_mode: 'Markdown' });
    logger.info({ jobId, days, interval, chatId }, 'Backfill triggered via Telegram');
  } catch (err) {
    logger.error({ err }, 'Failed to trigger backfill');
    ctx.reply('âŒ Failed to trigger backfill. Check system logs.');
  }
});

bot.command('livestatus', async (ctx) => {
  const chatId = ctx.chat.id;

  // Check if already streaming
  if (liveStatusSessions.has(chatId)) {
    return ctx.reply('ğŸ“¡ Live stream already active. Use /stop to end it first.');
  }

  const initialMsg = await ctx.reply('ğŸ“¡ *Live Console* - Connecting...', {
    parse_mode: 'Markdown',
  });
  const messageId = initialMsg.message_id;

  let lastLogIndex = 0;

  const updateStatus = async () => {
    try {
      const backfillData = await publisher.get('system:layer1:backfill');
      const logsRaw = await publisher.lRange('system:layer1:logs', 0, 9); // Last 10 logs

      const status = backfillData
        ? JSON.parse(backfillData)
        : { status: 0, progress: 0, details: 'Idle' };
      const logs = logsRaw || [];

      const statusIcon =
        status.status === 1 ? 'ğŸ”„' : status.status === 2 ? 'âœ…' : status.status === 3 ? 'âŒ' : 'â¸ï¸';
      const logLines = logs
        .slice(0, 5)
        .map((l, i) => `\`${i + 1}.\` ${l}`)
        .join('\n');

      const text =
        `ğŸ“¡ *Live Console*\n\n` +
        `${statusIcon} *Status*: ${status.status === 1 ? 'Running' : status.status === 2 ? 'Completed' : status.status === 3 ? 'Failed' : 'Idle'}\n` +
        `ğŸ“Š *Progress*: ${status.progress}%\n` +
        `ğŸ“ *Details*: ${status.details || '-'}\n\n` +
        `ğŸ–¥ï¸ *Recent Logs*:\n${logLines || '_No logs yet_'}\n\n` +
        `_Use /stop to end stream_`;

      await ctx.telegram.editMessageText(chatId, messageId, null, text, { parse_mode: 'Markdown' });

      // Auto-stop if completed or idle
      if (status.status === 2 || status.status === 0) {
        const session = liveStatusSessions.get(chatId);
        if (session) {
          clearInterval(session.intervalId);
          liveStatusSessions.delete(chatId);
          await ctx.telegram.editMessageText(
            chatId,
            messageId,
            null,
            text + '\n\nâœ… *Stream ended (job finished).*',
            { parse_mode: 'Markdown' }
          );
        }
      }
    } catch (err) {
      logger.error({ err }, 'Live status update error');
    }
  };

  // Update every 3 seconds
  const intervalId = setInterval(updateStatus, 3000);
  liveStatusSessions.set(chatId, { intervalId, messageId });

  // Initial update
  await updateStatus();
  logger.info({ chatId }, 'Live status stream started');
});

bot.command('stop', async (ctx) => {
  const chatId = ctx.chat.id;

  // Stop live status stream if active
  if (liveStatusSessions.has(chatId)) {
    const session = liveStatusSessions.get(chatId);
    clearInterval(session.intervalId);
    liveStatusSessions.delete(chatId);
    ctx.reply('ğŸ“¡ Live stream stopped.');
    return;
  }

  // Otherwise, unsubscribe from alerts
  try {
    await publisher.sRem('telegram:subscribers', chatId.toString());
    ctx.reply('ğŸ”• You have unsubscribed from alerts.');
  } catch {
    ctx.reply('âŒ Error unsubscribing.');
  }
});

// --- Notification Logic ---

async function broadcast(message) {
  try {
    const subscribers = await publisher.sMembers('telegram:subscribers');
    if (subscribers.length === 0) return;

    logger.info({ count: subscribers.length }, 'Broadcasting message');

    const promises = subscribers.map((chatId) =>
      bot.telegram
        .sendMessage(chatId, message, { parse_mode: 'Markdown' })
        .then(() => notificationsSent.inc({ type: 'alert' }))
        .catch((err) => {
          if (err.response && err.response.error_code === 403) {
            // User blocked bot
            publisher.sRem('telegram:subscribers', chatId);
          } else {
            logger.error({ err, chatId }, 'Failed to send message');
          }
        })
    );

    await Promise.all(promises);
  } catch (err) {
    logger.error({ err }, 'Broadcast error');
  }
}

// Broadcast with optional extra options (e.g., inline keyboard)
async function broadcastWithMarkup(message, extra = {}) {
  try {
    const subscribers = await publisher.sMembers('telegram:subscribers');
    if (subscribers.length === 0) return;

    logger.info({ count: subscribers.length }, 'Broadcasting message with markup');

    const promises = subscribers.map((chatId) =>
      bot.telegram
        .sendMessage(chatId, message, { parse_mode: 'Markdown', ...extra })
        .then(() => notificationsSent.inc({ type: 'alert' }))
        .catch((err) => {
          if (err.response && err.response.error_code === 403) {
            publisher.sRem('telegram:subscribers', chatId);
          } else {
            logger.error({ err, chatId }, 'Failed to send message');
          }
        })
    );

    await Promise.all(promises);
  } catch (err) {
    logger.error({ err }, 'Broadcast error');
  }
}

// --- Inline Button Callback Handlers ---
bot.action('cmd_ownanalysis', async (ctx) => {
  await ctx.answerCbQuery();
  // Simulate /ownanalysis
  const history = await publisher.lRange('signals:history', 0, 4);
  if (!history || history.length === 0) {
    return ctx.reply('ğŸ§  No recent analysis available.');
  }
  const msgs = history
    .map((item) => {
      const s = JSON.parse(item);
      const icon = s.action === 'BUY' ? 'ğŸŸ¢' : 'ğŸ”´';
      return `${icon} *${s.symbol}* (${s.action}) @ â‚¹${s.price}\n   Conf: ${(s.confidence * 100).toFixed(0)}%`;
    })
    .join('\n\n');
  ctx.reply(`ğŸ§  *Recent AI Analysis*\n\n${msgs}`, { parse_mode: 'Markdown' });
});

bot.action('cmd_movers', async (ctx) => {
  await ctx.answerCbQuery();
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const movers = market.most_active || market.top_gainers;
  const list = movers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸŒª *Most Active*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.action('cmd_high', async (ctx) => {
  await ctx.answerCbQuery();
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const list = market.top_gainers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸš€ *Top Gainers*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.action('cmd_low', async (ctx) => {
  await ctx.answerCbQuery();
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const list = market.top_losers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸ©¸ *Top Losers*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.action('cmd_feed', async (ctx) => {
  await ctx.answerCbQuery();
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const { breadth } = market;
  const msg =
    `ğŸ“Š *Market Snapshot* (${new Date().toLocaleTimeString()})\n\n` +
    `ğŸ“ˆ *Sentiment*: ${breadth.market_sentiment}\n` +
    `ğŸŸ¢ *Advance*: ${breadth.advance_count}\n` +
    `ğŸ”´ *Decline*: ${breadth.decline_count}\n` +
    `âš–ï¸ *A/D Ratio*: ${breadth.advance_decline.toFixed(2)}`;
  ctx.reply(msg, { parse_mode: 'Markdown' });
});

// Subscribe to Channels
async function startRedis() {
  await subscriber.connect();
  await publisher.connect();

  subscriber.subscribe('system:notifications', (message) => {
    broadcast(`ğŸ“¢ *System Notification*\n\n${message}`);
  });

  subscriber.subscribe('notifications:backfill', (message) => {
    try {
      const data = JSON.parse(message);
      const text =
        `ğŸ“¥ *Backfill Complete* âœ…\n\n` +
        `ğŸ“¦ *Symbol*: ${data.symbol || 'Nifty 50'}\n` +
        `ğŸ“… *Range*: ${data.start_date} to ${data.end_date}\n` +
        `ğŸ“Š *Records Added*: ${data.count}\n` +
        `â± *Duration*: ${data.duration}s\n\n` +
        `_Analytical Engine will now process this data._`;
      broadcast(text);
    } catch {
      logger.error('Invalid backfill msg');
    }
  });

  // New: Enhanced backfill status notifications
  subscriber.subscribe('backfill:status', (message) => {
    try {
      const data = JSON.parse(message);
      let text = '';
      let extra = {}; // For inline keyboard

      if (data.type === 'START') {
        text =
          `ğŸš€ *Backfill Job Started*\n\n` +
          `ğŸ“Š *Job ID*: \`${data.jobId}\`\n` +
          `ğŸ“¦ *Symbols*: ${data.symbols}\n` +
          `ğŸ“… *Range*: ${data.fromDate} to ${data.toDate}\n` +
          `â± *Interval*: ${data.interval}\n\n` +
          `_Processing historical data..._`;
      } else if (data.type === 'COMPLETE') {
        text =
          `âœ… *Backfill Job Complete*\n\n` +
          `ğŸ“Š *Job ID*: \`${data.jobId}\`\n` +
          `ğŸ“¦ *Symbols*: ${data.symbols}\n` +
          `ğŸ“… *Range*: ${data.fromDate} to ${data.toDate}\n` +
          `âœ… *Success*: ${data.successCount} symbols\n` +
          `âŒ *Failed*: ${data.failCount} symbols\n` +
          `ğŸ“ˆ *Total Candles*: ${data.totalCandles}\n` +
          `ğŸ’¾ *DB Rows*: ${data.dbRowsInserted}\n` +
          `â± *Duration*: ${data.durationSeconds}s\n\n` +
          `_Data ready for analysis! What would you like to do next?_`;

        // Add inline keyboard for post-backfill actions
        extra = {
          reply_markup: {
            inline_keyboard: [
              [
                { text: 'ğŸ§  AI Analysis', callback_data: 'cmd_ownanalysis' },
                { text: 'ğŸŒª Most Active', callback_data: 'cmd_movers' },
              ],
              [
                { text: 'ğŸš€ Top Gainers', callback_data: 'cmd_high' },
                { text: 'ğŸ©¸ Top Losers', callback_data: 'cmd_low' },
              ],
              [{ text: 'ğŸ“Š Market Feed', callback_data: 'cmd_feed' }],
            ],
          },
        };
      } else if (data.type === 'ERROR') {
        text =
          `âŒ *Backfill Job Failed*\n\n` +
          `ğŸ“Š *Job ID*: \`${data.jobId}\`\n` +
          `ğŸ”´ *Error*: ${data.error}\n\n` +
          `_Please check logs for details._`;
      }

      if (text) {
        // Broadcast with optional inline keyboard
        broadcastWithMarkup(text, extra);
      }
    } catch {
      logger.error('Invalid backfill:status msg');
    }
  });

  subscriber.subscribe('signals:new', (message) => {
    try {
      const signal = JSON.parse(message);
      const icon = signal.action === 'BUY' ? 'ğŸŸ¢' : 'ğŸ”´';
      const text =
        `${icon} *New Signal: ${signal.symbol}*\n` +
        `Action: *${signal.action}*\n` +
        `Price: ${signal.price}\n` +
        `Time: ${signal.timestamp}`;
      broadcast(text);
    } catch {
      logger.error('Invalid signal format');
    }
  });

  logger.info('âœ… Connected to Redis Pub/Sub');
}

// --- Express Server (Metrics/Health) ---

app.get('/metrics', async (req, res) => {
  res.setHeader('Content-Type', register.contentType);
  res.send(await register.metrics());
});

app.get('/health', (req, res) => {
  res.status(200).json({ status: 'UP', bot: 'Authorized' });
});

// Start Everything
async function main() {
  try {
    await startRedis();
    bot.launch(() => {
      logger.info('ğŸ¤– Telegram Bot Started');
      // Notify admin/subscribers of deployment
      broadcast(`ğŸ™ *Namaste Ji!* Guru Ji is back online. ğŸš€\n_System restarted successfully._`);
    });

    app.listen(port, () => {
      logger.info(`Server listening on port ${port}`);
    });

    // Graceful Stop
    process.once('SIGINT', () => {
      bot.stop('SIGINT');
      process.exit(0);
    });
    process.once('SIGTERM', () => {
      bot.stop('SIGTERM');
      process.exit(0);
    });
  } catch (err) {
    logger.error({ err }, 'Fatal Error');
    process.exit(1);
  }
}

main();
