const express = require('express');
const client = require('prom-client');
const { Telegraf } = require('telegraf');
const { createClient } = require('redis');
const pino = require('pino');

// Logger
const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    target: 'pino-pretty',
    options: { colorize: true },
  },
});

const app = express();
const port = process.env.PORT || 7000;
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const REDIS_URL = process.env.REDIS_URL || 'redis://redis:6379';

// Prometheus Registry
const register = new client.Registry();
client.collectDefaultMetrics({ register });

// Metrics
const notificationsSent = new client.Counter({
  name: 'telegram_notifications_sent_total',
  help: 'Total notifications sent to users',
  labelNames: ['type'],
});
register.registerMetric(notificationsSent);

// Initialize Redis
const subscriber = createClient({ url: REDIS_URL });
const publisher = createClient({ url: REDIS_URL });

subscriber.on('error', (err) => logger.error({ err }, 'Redis Subscriber Error'));
publisher.on('error', (err) => logger.error({ err }, 'Redis Publisher Error'));

// Initialize Bot
if (!BOT_TOKEN) {
  logger.error('TELEGRAM_BOT_TOKEN is missing. Bot will not start.');
  process.exit(1);
}

const bot = new Telegraf(BOT_TOKEN);

// --- Command Handlers ---

const HELP_MESSAGE = `
ğŸ™ *Namaste! I am Guru Ji* ğŸ§˜â€â™‚ï¸
Your AI-powered Nifty 50 Trading Assistant.

*Here is what I can do for you:*

ğŸš€ *Market Intelligence*
â€¢ /feed - *Market Snapshot*: Get filtered Advance/Decline ratios and broad market sentiment.
â€¢ /high - *Top Gainers*: List of top 10 stocks driving the market up.
â€¢ /low - *Top Losers*: List of top 10 stocks dragging the market down.
â€¢ /movers - *Most Active*: Stocks with the highest trading volume today.

ğŸ§  *AI Analysis*
â€¢ /ownanalysis - *Guru's Wisdom*: Recent Buy/Sell signals generated by the AI engine.
â€¢ /status - *System Health*: Check if the Guru is online and connected.

ğŸ’¡ *Feedback*
â€¢ /suggest <text> - Send feedback (Type message on SAME LINE!)

ğŸ“° *Updates*
â€¢ /news - *Market News*: Latest headlines (Coming Soon).
â€¢ /subscribe <email> - Get daily stock updates & feature changelogs via Email!
â€¢ /stop - Unsubscribe from alerts.

_Select a command above to start!_
`;

bot.start(async (ctx) => {
  const chatId = ctx.chat.id;
  const username = ctx.from.username || 'Trader';

  try {
    await publisher.sAdd('telegram:subscribers', chatId.toString());
    logger.info({ chatId, username }, 'New subscriber');
    ctx.reply(`Hello I am Guru Ji! ğŸ‘‹\nWelcome *${username}*.\n\n${HELP_MESSAGE}`, {
      parse_mode: 'Markdown',
    });
  } catch (err) {
    logger.error({ err }, 'Failed to subscribe user');
    ctx.reply('âŒ System Error: Could not subscribe.');
  }
});

bot.help((ctx) => {
  ctx.reply(HELP_MESSAGE, { parse_mode: 'Markdown' });
});

bot.command('suggest', async (ctx) => {
  const text = ctx.message.text.replace('/suggest', '').trim();
  logger.info({ user: ctx.from.username, text }, 'Suggestion Command Received');

  if (!text) {
    return ctx.reply(
      'âš ï¸ *Incorrect Format*\n\n' +
        'Please type the message on the *same line* as the command.\n\n' +
        'âœ… *Correct*:\n' +
        '`/suggest Add more charts`\n\n' +
        'âŒ *Wrong*:\n' +
        '`/suggest` [Enter]\n' +
        '(Typing message separately)',
      { parse_mode: 'Markdown' }
    );
  }

  try {
    const res = await axios.post('http://backend-api:4000/api/v1/suggestions', {
      user: ctx.from.username || 'Anonymous',
      text: text,
      source: 'telegram',
    });
    logger.info({ status: res.status, data: res.data }, 'Suggestion API Response');
    ctx.reply('ğŸ™ *Dhanyavac user*! Your suggestion has been noted.', { parse_mode: 'Markdown' });
  } catch (err) {
    logger.error({ err: err.message, stack: err.stack }, 'Suggestion Failed');
    ctx.reply('âŒ Failed to save suggestion. Try again later.');
  }
});

bot.command('subscribe', async (ctx) => {
  const email = ctx.message.text.replace('/subscribe', '').trim();
  const chatId = ctx.chat.id;
  const username = ctx.from.username || 'Anonymous';

  if (!email || !email.includes('@')) {
    return ctx.reply(
      'ğŸ“§ Please provide a valid email address.\nUsage: `/subscribe your@email.com`',
      { parse_mode: 'Markdown' }
    );
  }

  try {
    const res = await axios.post('http://backend-api:4000/api/v1/subscribers', {
      chatId: chatId,
      username: username,
      email: email,
    });

    if (res.data.success) {
      ctx.reply(
        'âœ… *Subscription Successful!* You are now on our list for regular updates and new feature releases.',
        { parse_mode: 'Markdown' }
      );
    } else {
      ctx.reply('âŒ Subscription failed. Please try again later.');
    }
  } catch (err) {
    logger.error({ err: err.message }, 'Subscription Failed');
    ctx.reply('âŒ System Error: Could not save subscription.');
  }
});

// --- Helper Functions ---
async function getMarketData() {
  const data = await publisher.get('market_view:latest');
  return data ? JSON.parse(data) : null;
}

const formatStock = (s) => `â€¢ *${s.symbol}*: ${s.change_pct.toFixed(2)}% (â‚¹${s.ltp})`;

bot.command('feed', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');

  const { breadth } = market;
  const msg =
    `ğŸ“Š *Market Snapshot* (${new Date().toLocaleTimeString()})\n\n` +
    `ğŸ“ˆ *Sentiment*: ${breadth.market_sentiment}\n` +
    `ğŸŸ¢ *Advance*: ${breadth.advance_count}\n` +
    `ğŸ”´ *Decline*: ${breadth.decline_count}\n` +
    `âš–ï¸ *A/D Ratio*: ${breadth.advance_decline.toFixed(2)}`;
  ctx.reply(msg, { parse_mode: 'Markdown' });
});

bot.command('high', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const list = market.top_gainers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸš€ *Top Gainers*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.command('low', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ğŸ“‰ Market data unavailable.');
  const list = market.top_losers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸ©¸ *Top Losers*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.command('movers', async (ctx) => {
  const market = await getMarketData();
  if (!market) return ctx.reply('ï¿½ Market data unavailable.');
  // Assuming most_active exists in market view schema, otherwise fallback to top_gainers
  const movers = market.most_active || market.top_gainers;
  const list = movers.slice(0, 10).map(formatStock).join('\n');
  ctx.reply(`ğŸŒª *Most Active*\n\n${list}`, { parse_mode: 'Markdown' });
});

bot.command('news', (ctx) => {
  ctx.reply('ğŸ“° *Latest News*\n\nFeature coming soon! Integration with NewsAPI pending.', {
    parse_mode: 'Markdown',
  });
});

bot.command('ownanalysis', async (ctx) => {
  try {
    // Fetch last 5 signals from Redis List
    // LRANGE signals:history 0 4
    const history = await publisher.lRange('signals:history', 0, 4);

    if (!history || history.length === 0) {
      return ctx.reply('ğŸ§  No recent analysis available.');
    }

    const msgs = history
      .map((item) => {
        const s = JSON.parse(item);
        const icon = s.action === 'BUY' ? 'ğŸŸ¢' : 'ğŸ”´';
        return `${icon} *${s.symbol}* (${s.action}) @ â‚¹${s.price}\n   Conf: ${(s.confidence * 100).toFixed(0)}% | ${new Date(s.timestamp).toLocaleTimeString()}`;
      })
      .join('\n\n');

    ctx.reply(`ğŸ§  *Recent AI Analysis*\n\n${msgs}`, { parse_mode: 'Markdown' });
  } catch (err) {
    logger.error({ err }, 'Analysis Fetch Error');
    ctx.reply('âŒ Error fetching analysis.');
  }
});

const cron = require('node-cron');
const axios = require('axios');

// --- Scheduled Tasks ---
// 9:00 AM IST (India) = 03:30 UTC
cron.schedule('30 3 * * 1-5', () => {
  const msg =
    `ğŸŒ… *Good Morning Traders!* â˜€ï¸\n` +
    `Markets are opening soon. Guru Ji wishes you high profits!\n` +
    `_Check /feed for pre-market sentiment._`;
  broadcast(msg);
});

bot.command('status', async (ctx) => {
  ctx.reply('ğŸ” *Checking System Health*...');

  const services = [
    { name: 'API', url: 'http://backend-api:4000/health' },
    { name: 'Ingestion', url: 'http://ingestion:3000/health' }, // Assuming L1 exposes 3000
    { name: 'Analysis', url: 'http://analysis:8081/health' },
    { name: 'Aggregation', url: 'http://aggregation:8080/health' },
    { name: 'Signal', url: 'http://signal:8082/health' },
  ];

  let report = `ğŸ¥ *System Health Report*\n\n`;

  for (const s of services) {
    try {
      await axios.get(s.url, { timeout: 2000 });
      report += `âœ… *${s.name}*: UP\n`;
    } catch {
      report += `âŒ *${s.name}*: DOWN\n`;
    }
  }

  // Redis Check
  try {
    await publisher.ping();
    report += `âœ… *Redis*: UP\n`;
  } catch {
    report += `âŒ *Redis*: DOWN\n`;
  }

  // Data Stats (from Redis)
  const vol = await publisher.get('stats:daily_volume');
  report += `\nğŸ“Š *Data Processed*: ${vol || 0} rows today`;

  ctx.reply(report, { parse_mode: 'Markdown' });
});

bot.command('stop', async (ctx) => {
  const chatId = ctx.chat.id;
  try {
    await publisher.sRem('telegram:subscribers', chatId.toString());
    ctx.reply('ğŸ”• You have unsubscribed from alerts.');
  } catch {
    ctx.reply('âŒ Error unsubscribing.');
  }
});

// --- Notification Logic ---

async function broadcast(message) {
  try {
    const subscribers = await publisher.sMembers('telegram:subscribers');
    if (subscribers.length === 0) return;

    logger.info({ count: subscribers.length }, 'Broadcasting message');

    const promises = subscribers.map((chatId) =>
      bot.telegram
        .sendMessage(chatId, message, { parse_mode: 'Markdown' })
        .then(() => notificationsSent.inc({ type: 'alert' }))
        .catch((err) => {
          if (err.response && err.response.error_code === 403) {
            // User blocked bot
            publisher.sRem('telegram:subscribers', chatId);
          } else {
            logger.error({ err, chatId }, 'Failed to send message');
          }
        })
    );

    await Promise.all(promises);
  } catch (err) {
    logger.error({ err }, 'Broadcast error');
  }
}

// Subscribe to Channels
async function startRedis() {
  await subscriber.connect();
  await publisher.connect();

  subscriber.subscribe('system:notifications', (message) => {
    broadcast(`ğŸ“¢ *System Notification*\n\n${message}`);
  });

  subscriber.subscribe('notifications:backfill', (message) => {
    try {
      const data = JSON.parse(message);
      const text =
        `ğŸ“¥ *Backfill Complete* âœ…\n\n` +
        `ğŸ“¦ *Symbol*: ${data.symbol || 'Nifty 50'}\n` +
        `ğŸ“… *Range*: ${data.start_date} to ${data.end_date}\n` +
        `ğŸ“Š *Records Added*: ${data.count}\n` +
        `â± *Duration*: ${data.duration}s\n\n` +
        `_Analytical Engine will now process this data._`;
      broadcast(text);
    } catch {
      logger.error('Invalid backfill msg');
    }
  });

  subscriber.subscribe('signals:new', (message) => {
    try {
      const signal = JSON.parse(message);
      const icon = signal.action === 'BUY' ? 'ğŸŸ¢' : 'ğŸ”´';
      const text =
        `${icon} *New Signal: ${signal.symbol}*\n` +
        `Action: *${signal.action}*\n` +
        `Price: ${signal.price}\n` +
        `Time: ${signal.timestamp}`;
      broadcast(text);
    } catch {
      logger.error('Invalid signal format');
    }
  });

  logger.info('âœ… Connected to Redis Pub/Sub');
}

// --- Express Server (Metrics/Health) ---

app.get('/metrics', async (req, res) => {
  res.setHeader('Content-Type', register.contentType);
  res.send(await register.metrics());
});

app.get('/health', (req, res) => {
  res.status(200).json({ status: 'UP', bot: 'Authorized' });
});

// Start Everything
async function main() {
  try {
    await startRedis();
    bot.launch(() => {
      logger.info('ğŸ¤– Telegram Bot Started');
      // Notify admin/subscribers of deployment
      broadcast(`ğŸ™ *Namaste Ji!* Guru Ji is back online. ğŸš€\n_System restarted successfully._`);
    });

    app.listen(port, () => {
      logger.info(`Server listening on port ${port}`);
    });

    // Graceful Stop
    process.once('SIGINT', () => {
      bot.stop('SIGINT');
      process.exit(0);
    });
    process.once('SIGTERM', () => {
      bot.stop('SIGTERM');
      process.exit(0);
    });
  } catch (err) {
    logger.error({ err }, 'Fatal Error');
    process.exit(1);
  }
}

main();
